<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Angular">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://ngclub.com/angular">
    <!--SEO-->

<meta name="description" content="仰山而铸铜 煮海而为盐">



<meta name="keywords" content="angualr react vue">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">
    <!--Title-->


<title>你不得不了解的flutter | Angular</title>


    <link rel="alternate" href="/atom.xml" title="Angular" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="大力">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 仰山而铸铜 煮海而为盐 </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://ngclub.com/angular">Angular</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/angular/"><i class="fa "></i>Angular</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/relearning/"><i class="fa "></i>重学前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/vue/"><i class="fa "></i>Vue</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/react/"><i class="fa "></i>React</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/flutter/"><i class="fa "></i>flutter</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="你不得不了解的flutter">
            
	            你不得不了解的flutter
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/flutter">
            flutter
        </a>
    </span>
    

    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/前端" title="前端">
                        前端
                    </a>
                
                    <a href="/tags/flutter" title="flutter">
                        flutter
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/01/29</span>
        </span>
        
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Flutter 是谷歌的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。 Flutter 可以与现有的代码一起工作。在全世界，Flutter 正在被越来越多的开发者和组织使用，并且 Flutter 是完全免费、开源的。</p>
<h2 id="为什么要用-Flutter-？"><a href="#为什么要用-Flutter-？" class="headerlink" title="为什么要用 Flutter ？"></a>为什么要用 Flutter ？</h2><ul>
<li>提高开发效率，同一份代码开发 iOS 和 Android，对于开发者可以轻松跨端开发，提升竞争力；</li>
<li>受益于使用 Flutter 框架提供的丰富的 Material Design 和 Cupertino（ iOS 风格）的 Widget，可以很轻松的在 iOS 平台上实现 Material 设计风格的用户体验；</li>
<li>用更少的代码做更多的事情，通过丰富的属性设置，可以实现很炫的效果；</li>
<li>在应用程序运行时更改代码并重新加载（HotReload），这个点真的是 App 开发质的提升；</li>
<li>现代化的、响应式的框架、Redux、RxDart、BloC 等等框架可以帮助你逻辑和 UI 优雅的分离；</li>
<li>轻松实现网络、异步、IO 等基础功能；</li>
<li>国内阿里咸鱼、腾讯、京东、国外的谷歌等公司都已经有上线产品在使用 Flutter 开发，即使没有上线的也基本在上线的路上了。<h2 id="Flutter-框架结构"><a href="#Flutter-框架结构" class="headerlink" title="Flutter 框架结构"></a>Flutter 框架结构</h2></li>
</ul>
<p><img src="/img/flutter-1-1.png" alt="image"><br>图片来源： <a href="https://flutter.io" target="_blank" rel="noopener">https://flutter.io</a></p>
<h3 id="Flutter-Framework"><a href="#Flutter-Framework" class="headerlink" title="Flutter Framework"></a>Flutter Framework</h3><p>Framework 这一层使用 Dart 语言开发，它实现了一套基础库。<br>Foundation、Animation、Painting、Gestures 为 Dart 实现的 UI 层，提供动画、手势及绘制。<br>Rendering 渲染层，依赖 UI 层，在运行时 Rendering 层会构建一个 Widget 树，当有变化时，会更具一定的算法计算出有变化的部分，然后更新 Widget 树。<br>Widgets 层是 Flutter 提供的的一套基础组件库，在基础组件库之上，Flutter 还提供了 Material 和 Cupertino 两种视觉风格的组件库。</p>
<h3 id="Flutter-Engine"><a href="#Flutter-Engine" class="headerlink" title="Flutter Engine"></a>Flutter Engine</h3><p>Skia 是个 2D 向量图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现。不仅用于 Google Chrome 浏览器，新兴的 Android 开放手机平台也采用 Skia 作为绘图处理，搭配 OpenGL/ES 与特定的硬件特征，强化显示的效果。</p>
<p> 正式因为没有使用原声的 UI 和绘制框架，所以才保证了 Flutter 的高性能体验。</p>
<h2 id="一切皆为-Widget"><a href="#一切皆为-Widget" class="headerlink" title="一切皆为 Widget"></a>一切皆为 Widget</h2><p>Widget 是 Flutter 应用程序用户界面的基本构建块，你能看到的和看不到的都是一个 Widget，可以分为以下几种类型:</p>
<ul>
<li>基础部件：Text、Image、Button、单选框、复选框、输入框、表单等；</li>
<li>布局容器类：Wrap、Flow、Row、Column、Container、Stack 等；</li>
<li>功能类：ListView，GridView，InheritedWidget 等。<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3>Flutter 提供响应式视图，无需任何 Javascript 桥接器与平台通信。Flutter 提供了大量的 Material Design 灵感组件，可以在应用程序中使用。</li>
</ul>
<p>另外 IDE 推荐使用 Visual Studio Code，你可以下载安装 Flutter 插件，可以直接在编辑器选择真是设备或模拟器上调试和运行应用程序。Android Studio 或 IntelliJ 也都支持 Flutter 开发。</p>
<h1 id="Dart-介绍"><a href="#Dart-介绍" class="headerlink" title="Dart 介绍"></a>Dart 介绍</h1><p>最初设计 Dart，是 Google 决定设计一个新语言用来替换 JavaScript 的，所以刚开始 Dart 也就是用来作为浏览器脚本运行在浏览器中的。为了推广 Dart，Google 利用自己的利器 Chrome 让它内置了 DartVM 的引擎。有了运行环境，加上用户群的可观数量，Dart 最初也赢得了部分前端开发者的青睐。</p>
<h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><ul>
<li>单进程异步事件模型；</li>
<li>强类型，可以类型推断；</li>
<li>DartVM，具有极高的运行效率和优秀的代码运行优化，根据早前的基准测试，性能比肩 Java7 的 JVM；</li>
<li>独特的隔离区( Isolate )，可以实现多线程；</li>
<li>面向对象编程，一切数据类型均派生自 Object；</li>
<li>运算符重载，泛型支持；</li>
<li>强大的 Future 和 Stream 模型，可以简单实现高效的代码；</li>
<li>Minix 特性，可以更好的实现方法复用；</li>
<li>全平台语言，可以很好的胜任移动和前后端的开发。<br>在语法上，Dart 提供了很多便捷的操作，可以明显减少代码量。比如字符连接，可以直接 “my name is name,ageisname,ageisage”，无需+号拼接，也无需做类型转换。<br>你可以直接进入 <a href="https://www.dartlang.org。open" target="_blank" rel="noopener">https://www.dartlang.org。open</a> in dartpad，打开一个新页面，在不安装任何工具的情况下，编写 Dart 语言代码。</li>
</ul>
<p>Dart 语言与其他语言一样都有一个 main 函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">    print (&quot;hello dart&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Dart 语言的代码注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//单行注释</span><br><span class="line">/*</span><br><span class="line">  多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>使用 var 声明变量，无需指定具体类型。Dart 是强类型语言，在编译时贵根据第一次赋值判断并设置其类型，所以 var 变量一旦赋值，类型便确定，且不能在修改类型，只能修改其值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var p;</span><br><span class="line">p = &quot;Hello Dart&quot;;</span><br><span class="line">//这里会出现错误。</span><br><span class="line">p = 1000；</span><br></pre></td></tr></table></figure></p>
<p>Dynamic 和 Object<br>实际开发中确实可能会有类型转换的情景，所以 Dart 提供了 Dynamic 和 Object。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dynamic p;</span><br><span class="line">p = &quot;Hello Dart&quot;;</span><br><span class="line">//这里没有问题。</span><br><span class="line">p = 1000；</span><br></pre></td></tr></table></figure></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>num 数字类型的父类，两个子类 int、double；</li>
<li>String 使用单引号或者双引号创建字符串，单双引号可以嵌套。使用 ${}可以加入其他变量拼接计算字符串；</li>
<li>bool true 和 false；</li>
<li>List 数组；<br> a. 定义List list = [‘a’,’b’,’c’];<br> b. add 添加元素；<br> c. addAll 添加多个元素；<br> d. length 长度；<br> e. first 第一个元素，等同[0]；<br> f. indexOf 定位某元素；<br> g. removeAt 移除某元素；<br> h. removeLast 移除最后一个元素；<br> i. clear 清除所有元素。</li>
<li><p>Map 集合，类似OC中的 Dic，由键和值构成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var iMap = new Map&lt;int,String&gt;();</span><br></pre></td></tr></table></figure>
<p>异常<br>throw:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw:抛出异常：throw new FormatException(&apos;this is a exception&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>catch:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    dosomething();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">    // A specific exception</span><br><span class="line">    buyMoreLlamas();</span><br><span class="line">&#125; on Exception catch (e) &#123;</span><br><span class="line">    // Anything else that is an exception</span><br><span class="line">    print(&apos;Unknown exception: $e&apos;);</span><br><span class="line">&#125; catch (e, s) &#123;</span><br><span class="line">    print(&apos;Exception details:\n $e&apos;);</span><br><span class="line">    print(&apos;Stack trace:\n $s&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rethrow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final foo = &apos;&apos;;</span><br><span class="line">void misbehave() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      foo = &quot;1&quot;;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      print(&apos;2&apos;);</span><br><span class="line">      rethrow;// 如果不重新抛出异常，main函数中的catch语句执行不到</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      misbehave();</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      print(&apos;3&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>finally</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final foo = &apos;&apos;;</span><br><span class="line">void misbehave() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      foo = &quot;1&quot;;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      print(&apos;2&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void main() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      misbehave();</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      print(&apos;3&apos;);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      print(&apos;4&apos;); // 即使没有rethrow最终都会执行到</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在 Dart 中，函数也是对象。</p>
<ul>
<li><p>支持可选参数，使用{}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void action(&#123;bool flag,bool show&#125;) &#123;</span><br><span class="line">    print(&apos;action&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可选的位置参数，使用[]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String say(String from, String msg, [String device]) &#123;</span><br><span class="line">      var result = &apos;$from says $msg&apos;;</span><br><span class="line">      if (device != null) &#123;</span><br><span class="line">         result = &apos;$result with a $device&apos;;</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认参数；</p>
</li>
<li>函数参数,函数作为一个参数传递；</li>
<li>函数变量，可以把一个函数赋值给变量；</li>
<li>匿名函数，iOS block，函数指针概念相同；</li>
<li>所有函数都有一个返回值，默认返回 null。<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2></li>
<li>Dart 是 OO（object-oriented）类型的语言，支持 mixin 的继承方式；</li>
<li>创建一个对象，当然是用 new 和 constructor 一起。Dart 2 中可以省略 new；</li>
<li>用.操作符来访问成员变量以及成员函数；</li>
<li>没有设定初始值的实例变量为 null；</li>
<li>用?.来避免 null. 这个和 Kotlin、Swift 一样， 防 null 的；</li>
<li>实例变量自动带 getter function. 如果这个实例变量没有用 final 定义, 也会自动生成 setter；</li>
<li>Dart 有简单的写构造函数的方法；</li>
<li>如果没有命名构造函数, 那么 Dart 会帮我们创建一个空参的构造函数；</li>
<li>Named constructor 这个很有意思. 如果我们想有多个构造函数. 需要我们不同命名；</li>
<li>static const 类常量；</li>
<li>const 还可以创建常量值；</li>
<li>初始化列表，除了调用父类的构造。<br>更多 Dart 语言的介绍移步官网。</li>
</ul>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="安装-Flutter"><a href="#安装-Flutter" class="headerlink" title="安装 Flutter"></a>安装 Flutter</h2><p>要安装和运行 Flutter，您的开发环境必须满足以下最低要求：</p>
<ul>
<li>操作系统：macOS（64位）</li>
<li>磁盘空间：700 MB（不包括 IDE /工具的磁盘空间）。</li>
<li>工具：Flutter 取决于您的环境中可用的这些命令行工具。 bash、mkdir、rm、git、curl、unzip、which</li>
<li>下载：打开 <a href="https://flutter.io/docs/get-started/install，下载对应平台的" target="_blank" rel="noopener">https://flutter.io/docs/get-started/install，下载对应平台的</a> fluttermacosv1.0.0-stable.zip</li>
</ul>
<p><img src="/img/flutter-1-2.png" alt="image"><br>图片来源：Flutter 官网</p>
<ul>
<li>解压：unzip ~/Downloads/fluttermacosv1.0.0-stable.zip<br>-将 flutter 工具添加到您的路径： export PATH=$PATH:pwd/flutter/bin<br>您现在可以运行 Flutter 命令了！</li>
</ul>
<h2 id="环境诊断"><a href="#环境诊断" class="headerlink" title="环境诊断"></a>环境诊断</h2><p>执行如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/flutter-1-3.png" alt="image"></p>
<p>如果提示出现：! Doctor found issues in 1 category.则按详细提示内容安装对应的工具即可。</p>
<h2 id="升级-Flutter"><a href="#升级-Flutter" class="headerlink" title="升级 Flutter"></a>升级 Flutter</h2><p>Flutter SDK 有多个分支，如 beta、dev、master，stable 。其中 stable 分支为稳定分支，dev 和 master 为开发分支，安装 flutter 后，你可以运行 flutter channel 查看所有分支。</p>
<p>带 “*” 号的分支即你本地的 Flutter SDK 跟踪的分支，要切换分支，可以使用 flutter channel beta 或 flutter channel master。</p>
<p>升级Flutter SDK：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure></p>
<p>获取项目所有的依赖包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get。</span><br></pre></td></tr></table></figure></p>
<p>获取项目所有依赖包的最新版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter packages upgrade</span><br></pre></td></tr></table></figure></p>
<p>更多命令行操作可以输入 flutter 回车查看。</p>
<h1 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h1><p>打开 VS Code 扩展面板，输入 flutter 点击安装。输入 Dart 点击安装。<br><img src="/img/flutter-1-4.png" alt="image"></p>
<h2 id="创建-Flutter-项目"><a href="#创建-Flutter-项目" class="headerlink" title="创建 Flutter 项目"></a>创建 Flutter 项目</h2><p>安装 Flutter 后，按下 cmd + shift + p，选择 Flutter：New Project，按提示创建 helloflutter 工程。</p>
<p><img src="/img/flutter-1-5.png" alt="image"></p>
<h2 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h2><p><img src="/img/flutter-1-6.png" alt="image"></p>
<ol>
<li>Android、iOS 一看就明白吧，原生工程在这里，原生代码也在这里写；</li>
<li>lib Flutter 代码在这里创建，类似 main.dart；</li>
<li>test 单元测试，所有测试用例可以写这个目录下；</li>
<li>pubspec.lock 类似 iOS 的 cocoapods，Android 的 Gradle，第三方库配置。<h2 id="iOS-运行项目"><a href="#iOS-运行项目" class="headerlink" title="iOS 运行项目"></a>iOS 运行项目</h2></li>
</ol>
<p><img src="/img/flutter-1-7.png" alt="image"></p>
<ol>
<li>首先使用 XCode 打开 iOS 目录下的 Runner.xcworkspace 工程文件，配置开发者账号、AppID 和证书等信息；</li>
<li>点击右下角设备列表，选择对应的设备，选择左边栏的‘调试’，绿色箭头启动调试；</li>
<li>启动模拟器：首先查看模拟器列表 ‘xcrun instruments -s’，然后 ‘xcrun instruments -w “iPhone SE (12.1)”’，这样就可以启动 iPhone SE (12.1)，然后在 VSCode 中就可以选择这个模拟器运行代码。<h2 id="Android-运行项目"><a href="#Android-运行项目" class="headerlink" title="Android 运行项目"></a>Android 运行项目</h2></li>
<li>首先连接安卓设备，打开开发者调试开关；</li>
<li>VSCode 选择对应的设备，然后 run 即可。<h1 id="基础部件"><a href="#基础部件" class="headerlink" title="基础部件"></a>基础部件</h1><h2 id="Wideget-简介"><a href="#Wideget-简介" class="headerlink" title="Wideget 简介"></a>Wideget 简介</h2>Flutter Widget 采用现代响应式框架构建，这是从 React 中获得的灵感，中心思想是用 Widget 构建你的 UI。 Widget 描述了他们的视图在给定其当前配置和状态时应该看起来像什么。当 Widget 的状态发生变化时，Widget 会重新构建 UI，Flutter 会对比前后变化的不同， 以确定底层渲染树从一个状态转换到下一个状态所需的最小更改。</li>
</ol>
<h2 id="Widget-与-Element"><a href="#Widget-与-Element" class="headerlink" title="Widget 与 Element"></a>Widget 与 Element</h2><p>Widget 实际上就是 Element 的配置数据，Widget 树实际上是一个配置树，而真正的 UI 渲染树是由 Element 构成；不过，由于 Element 是通过 Widget 生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@immutable</span><br><span class="line">abstract class Widget extends DiagnosticableTree &#123;</span><br><span class="line">  const Widget(&#123; this.key &#125;);</span><br><span class="line">  final Key key;</span><br><span class="line">  @protected</span><br><span class="line">  Element createElement();</span><br><span class="line">  @override</span><br><span class="line">  String toStringShort() &#123;</span><br><span class="line">    return key == null ? &apos;$runtimeType&apos; : &apos;$runtimeType-$key&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  void debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    super.debugFillProperties(properties);</span><br><span class="line">    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;</span><br><span class="line">  &#125;</span><br><span class="line">  static bool canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    return oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Widget 类继承自 DiagnosticableTree，DiagnosticableTree 即“诊断树”，主要作用是提供调试信息；</li>
<li>Key：这个 key 属性类似于 React/Vue 中的 key，主要的作用是决定是否在下一次 build 时复用旧的；</li>
<li>widget，决定的条件在 canUpdate() 方法中；</li>
<li>createElement()：正如前文所述“一个 Widget 可以对应多个 Element”；Flutter Framework 在构建 UI 树时，会先调用此方法生成对应节点的 Element 对象。此方法是 - - Flutter Framework 隐式调用的，在我们开发过程中基本不会调用到；</li>
<li>debugFillProperties(…) 复写父类的方法，主要是设置诊断树的一些特性；</li>
<li>canUpdate(…)是一个静态方法，它主要用于在 Widget 树重新 build 时复用旧的 widget，其实具体来说，应该是：是否用新的 Widget 对象去更新旧UI树上所对应的 Element - 对象的配置；通过其源码我们可以看到，只要 newWidget 与 oldWidget 的 runtimeType 和 key 同时相等时就会用 newWidget 去更新 Element 对象的配置，否则就会创建新的 Element。</li>
</ul>
<p>Widget 类本身是一个抽象类，其中最核心的就是定义了 createElement() 接口，在 Flutter 开发中，我们一般都不用直接继承 Widget 类来实现 Widget，相反，我们通常会通过继承 StatelessWidget 和 StatefulWidget 来间接继承 Widget 类来实现，而 StatelessWidget 和 StatefulWidget 都是直接继承自 Widget 类。</p>
<h2 id="Stateless-Widget"><a href="#Stateless-Widget" class="headerlink" title="Stateless Widget"></a>Stateless Widget</h2><p>StatelessWidget 用于不需要维护状态的场景，它通常在 build 方法中通过嵌套其它 Widget 来构建 UI，在构建过程中会递归的构建其嵌套的 Widget。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Page extends StatelessWidget &#123;</span><br><span class="line">  final String title;</span><br><span class="line">  Page(&#123;Key key,this.title,&#125;);</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">     appBar: AppBar(</span><br><span class="line">       title: Text(title),</span><br><span class="line">     ),</span><br><span class="line">      body: Container(</span><br><span class="line">        child:Text(title),</span><br><span class="line">        color: Colors.yellow,</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Stateful-Widget"><a href="#Stateful-Widget" class="headerlink" title="Stateful Widget"></a>Stateful Widget</h2><p>同 StatelessWidget 不同，StatefulWidget 可以拥有状态变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class LoginPage extends StatefulWidget &#123;</span><br><span class="line">  _LoginPageState createState() =&gt; _LoginPageState();</span><br><span class="line">&#125;</span><br><span class="line">class _LoginPageState extends State&lt;LoginPage&gt; &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">       child: Text(&apos;data&apos;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基础-Widget"><a href="#基础-Widget" class="headerlink" title="基础 Widget"></a>基础 Widget</h2><table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">作用特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MaterialApp</td>
<td style="text-align:left">一般作为 APP 顶层的主页入口，可配置主题，多语言，路由等</td>
</tr>
<tr>
<td style="text-align:left">Scaffold</td>
<td style="text-align:left">一般用户页面的承载 Widget，包含 appbar、snackbar、drawer 等 material design 的设定。</td>
</tr>
<tr>
<td style="text-align:left">Appbar</td>
<td style="text-align:left">一般用于 Scaffold 的 appbar ，内有标题，二级页面返回按键等，当然不止这些，tabbar 等也会需要它 。</td>
</tr>
<tr>
<td style="text-align:left">Text</td>
<td style="text-align:left">显示文本，几乎都会用到，主要是通过 style 设置 TextStyle 来设置字体样式等。</td>
</tr>
<tr>
<td style="text-align:left">RichText</td>
<td style="text-align:left">富文本，通过设置 TextSpan，可以拼接出富文本场景。</td>
</tr>
<tr>
<td style="text-align:left">TextField</td>
<td style="text-align:left">文本输入框 ：new TextField(controller: //文本控制器, obscureText: “hint文本”);</td>
</tr>
<tr>
<td style="text-align:left">Image</td>
<td style="text-align:left">图片加载: new FadeInImage.assetNetwork( placeholder: “预览图”, fit: BoxFit.fitWidth, image: “url”);</td>
</tr>
<tr>
<td style="text-align:left">FlatButton</td>
<td style="text-align:left">按键点击: new FlatButton(onPressed: () {},child: new Container());</td>
</tr>
</tbody>
</table>
<h3 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h3><p>Text 用于显示简单样式文本，它包含一些控制文本显示样式的一些属性，一个简单的例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Text(&quot;Hello world&quot;,</span><br><span class="line">  textAlign: TextAlign.center,</span><br><span class="line">);</span><br><span class="line">Text(&quot;Hello world! I&apos;m Jack. &quot;*4,</span><br><span class="line">  maxLines: 1,</span><br><span class="line">  overflow: TextOverflow.ellipsis,</span><br><span class="line">);</span><br><span class="line">Text(&quot;Hello world&quot;,</span><br><span class="line">  textScaleFactor: 1.5,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>textAlign：文本的对齐方式；可以选择左对齐、右对齐还是居中。</p>
<p>maxLines：指定文本显示的最大行数。</p>
<p>overflow：指定截断方式，默认是直接截断，TextOverflow.ellipsis，它会将多余文本截断后以省略符“…”表示。</p>
<p>textScaleFactor：代表文本相对于当前字体大小的缩放因子。</p>
<p>TextStyle：用于指定文本显示的样式如颜色、字体、粗细、背景等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Text(&quot;Hello world&quot;,</span><br><span class="line">  style: TextStyle(</span><br><span class="line">    color: Colors.blue,</span><br><span class="line">    fontSize: 18.0,</span><br><span class="line">    height: 1.2,  </span><br><span class="line">    fontFamily: &quot;Courier&quot;,</span><br><span class="line">    background: new Paint()..color=Colors.yellow,</span><br><span class="line">    decoration:TextDecoration.underline,</span><br><span class="line">    decorationStyle: TextDecorationStyle.dashed</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>常用按钮有 RaisedButton、FlatButton、OutlineButton、IconButton 等，按下时都会有“水波动画”，有一个 onPressed 属性来设置点击回调。</p>
<p>RaisedButton<br>RaisedButton 即”漂浮”按钮，它默认带有阴影和灰色背景。按下后，阴影会变大</p>
<p>使用 RaisedButton 非常简单，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RaisedButton(</span><br><span class="line">  child: Text(&quot;RaisedButton&quot;),</span><br><span class="line">  onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure></p>
<h3 id="FlatButton"><a href="#FlatButton" class="headerlink" title="FlatButton"></a>FlatButton</h3><p>FlatButton 即扁平按钮，默认背景透明并不带阴影。按下后，会有背景色</p>
<p>使用 FlatButton 也很简单，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FlatButton(</span><br><span class="line">  child: Text(&quot;FlatButton&quot;),</span><br><span class="line">  onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure></p>
<h3 id="OutlineButton"><a href="#OutlineButton" class="headerlink" title="OutlineButton"></a>OutlineButton</h3><p>OutlineButton 默认有一个边框，不带阴影且背景透明。按下后，边框颜色会变亮、同时出现背景和阴影(较弱)：</p>
<p>使用 OutlineButton 也很简单，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OutlineButton(</span><br><span class="line">  child: Text(&quot;OutlineButton&quot;),</span><br><span class="line">  onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure></p>
<h3 id="IconButton"><a href="#IconButton" class="headerlink" title="IconButton"></a>IconButton</h3><p>IconButton 是一个可点击的 Icon，不包括文字，默认没有背景，点击后会出现背景：</p>
<p>使用代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IconButton(</span><br><span class="line">  icon: Icon(Icons.thumb_up),</span><br><span class="line">  onPressed: () =&gt; &#123;&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h3 id="自定义按钮外观"><a href="#自定义按钮外观" class="headerlink" title="自定义按钮外观"></a>自定义按钮外观</h3><p>按钮外观可以通过其属性来定义，不同按钮属性大同小异，我们以 FlatButton 为例，介绍一下常见的按钮属性，详细的信息可以查看 API 文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const FlatButton(&#123;</span><br><span class="line">  ...  </span><br><span class="line">  @required this.onPressed, //按钮点击回调</span><br><span class="line">  this.textColor, //按钮文字颜色</span><br><span class="line">  this.disabledTextColor, //按钮禁用时的文字颜色</span><br><span class="line">  this.color, //按钮背景颜色</span><br><span class="line">  this.disabledColor,//按钮禁用时的背景颜色</span><br><span class="line">  this.highlightColor, //按钮按下时的背景颜色</span><br><span class="line">  this.splashColor, //点击时，水波动画中水波的颜色</span><br><span class="line">  this.colorBrightness,//按钮主题，默认是浅色主题 </span><br><span class="line">  this.padding, //按钮的填充</span><br><span class="line">  this.shape, //外形</span><br><span class="line">  @required this.child, //按钮的内容</span><br><span class="line">&#125;)</span><br><span class="line">``` </span><br><span class="line">示例</span><br><span class="line">定义一个背景蓝色，两边圆角的按钮。代码如下：</span><br></pre></td></tr></table></figure></p>
<p>FlatButton(<br>  color: Colors.lightBlue,<br>  highlightColor: Colors.blue,<br>  colorBrightness: Brightness.dark,<br>  splashColor: Colors.yellow,<br>  child: Text(“确定”),<br>  shape: RoundedRectangleBorder(<br>      borderRadius: BorderRadius.circular(10.0)),<br>  onPressed: () =&gt; {},<br>),<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">### Image</span><br><span class="line">Flutter 中，我们可以通过 Image 来加载并显示图片，Image 的数据源可以是 asset、文件、内存以及网络。</span><br><span class="line"></span><br><span class="line">ImageProvider 是一个抽象类，主要定义了图片数据获取的接口 load()，从不同的数据源获取图片需要实现不同的 ImageProvider ，如 AssetImage 是实现了从 Asset 中加载图片的 ImageProvider，而 NetworkImage 实现了从网络加载图片的 ImageProvider。</span><br><span class="line"></span><br><span class="line">Image widget 有一个必选的 image 参数，它对应一个 ImageProvider。下面我们分别演示一下如何从 asset 和网络加载图片。</span><br><span class="line"></span><br><span class="line">#### 从 asset 中加载图片</span><br><span class="line">在工程根目录下创建一个 images 目录，并将图片 avatar.png 拷贝到该目录。</span><br><span class="line"></span><br><span class="line">在 pubspec.yml 中的 flutter 部分添加如下内容：</span><br><span class="line"></span><br><span class="line">assets:</span><br></pre></td></tr></table></figure></p>
<p>images/avatar.png<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 加载本地图片</span><br></pre></td></tr></table></figure></p>
<p>Image(<br>  image: AssetImage(“images/avatar.png”),<br>  width: 100.0<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 加载网络图片</span><br></pre></td></tr></table></figure></p>
<p>Image.network(<br>  “<a href="https://www.baidu.com/img/qxinshouye_a5df87f73cde439ec5d07aeb94e7db72.png&quot;" target="_blank" rel="noopener">https://www.baidu.com/img/qxinshouye_a5df87f73cde439ec5d07aeb94e7db72.png&quot;</a>,<br>  width: 100.0,<br>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 参数</span><br><span class="line">Image 在显示图片时定义了一系列参数，通过这些参数我们可以控制图片的显示外观、大小、混合效果等。我们看一下 Image 的主要参数：</span><br></pre></td></tr></table></figure></p>
<p>const Image({<br>  …<br>  this.width, //图片的宽<br>  this.height, //图片高度<br>  this.color, //图片的混合色值<br>  this.colorBlendMode, //混合模式<br>  this.fit,//缩放模式<br>  this.alignment = Alignment.center, //对齐方式<br>  this.repeat = ImageRepeat.noRepeat, //重复方式<br>  …<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- width、height：用于设置图片的宽、高，当不指定宽高时，图片会根据当前父容器的限制，尽可能的显示其原始大小，如果只设置 width、height 的其中一个，那么另一个属性默认- 会按比例缩放，但可以通过下面介绍的 fit 属性来指定适应规则；</span><br><span class="line">- fit：该属性用于在图片的显示空间和图片本身大小不同时指定图片的适应模式，适应模式是在 BoxFit 中定义；</span><br><span class="line">- fill：会拉伸填充满显示空间，图片本身长宽比会发生变化，图片会变形；</span><br><span class="line">- cover：会按图片的长宽比放大后居中填满显示空间，图片不会变形，超出显示空间部分会被剪裁；</span><br><span class="line">- contain：这是图片的默认适应规则，图片会在保证图片本身长宽比不变的情况下缩放以适应当前显示空间，图片不会变形；</span><br><span class="line">- fitWidth：图片的宽度会缩放到显示空间的宽度，高度会按比例缩放，然后居中显示，图片不会变形，超出显示空间部分会被剪裁；</span><br><span class="line">- fitHeight：图片的高度会缩放到显示空间的高度，宽度会按比例缩放，然后居中显示，图片不会变形，超出显示空间部分会被剪裁；</span><br><span class="line">- none：图片没有适应策略，会在显示空间内显示图片，如果图片比显示空间大，则显示空间只会显示图片中间部分。</span><br><span class="line"></span><br><span class="line">color 和 colorBlendMode：在图片绘制时可以对每一个像素进行颜色混合处理，color 指定混合色，而 colorBlendMode 指定混合模式，下面是一个简单的示例：</span><br></pre></td></tr></table></figure></p>
<p>Image(<br>  image: AssetImage(“images/avatar.png”),<br>  width: 100.0,<br>  color: Colors.blue,<br>  colorBlendMode: BlendMode.difference,<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeat：当图片本身大小小于显示空间时，指定图片的重复规则。简单示例如下：</span><br></pre></td></tr></table></figure></p>
<p>Image(<br>  image: AssetImage(“images/avatar.png”),<br>  width: 100.0,<br>  height: 200.0,<br>  repeat: ImageRepeat.repeatY ,<br>)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ICON</span><br><span class="line">Flutter 中，可以像 Web 开发一样使用 iconfont，iconfont 即“字体图标”，它是将图标做成字体文件，然后通过制定不同的字符而显示不同的图片。</span><br><span class="line"></span><br><span class="line">在字体文件中，每一个字符都对应一个位码，而每一个位码对应一个显示字形，不同的字体就是指字形不同，即字符对应的字形是不同的。而在 iconfont 中，只是将位码对应的字形做成了图标，所以不同的字符最终就会渲染成不同的图标。</span><br><span class="line"></span><br><span class="line">在 Flutter 开发中，iconfont 和图片相比有如下优势：</span><br><span class="line"></span><br><span class="line">- 体积小：可以减小安装包大小；</span><br><span class="line">- 矢量的：iconfont 都是矢量图标，放大不会影响其清晰度；</span><br><span class="line">- 可以应用文本样式：可以像文本一样改变字体图标的颜色、大小对齐等；</span><br><span class="line">- 可以通过 TextSpan 和文本混用；</span><br><span class="line">- 使用 Material Design 字体图标；</span><br><span class="line">- Flutter 默认包含了一套 Material Design 的字体图标，在 pubspec.yaml 文件中的配置如下：</span><br></pre></td></tr></table></figure></p>
<p> flutter:<br>  uses-material-design: true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Material Design 所有图标可以在其官网查看：https://material.io/tools/icons/</span><br><span class="line"></span><br><span class="line">我们看一个简单的例子：</span><br></pre></td></tr></table></figure></p>
<p>String icons = “”;<br>// accessible: &#xE914; or 0xE914 or E914<br>icons += “\uE914”;<br>// error: &#xE000; or 0xE000 or E000<br>icons += “ \uE000”;<br>// fingerprint: &#xE90D; or 0xE90D or E90D<br>icons += “ \uE90D”;<br>Text(icons,<br>  style: TextStyle(<br>      fontFamily: “MaterialIcons”,<br>      fontSize: 24.0,<br>      color: Colors.green<br>  ),<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用自定义字体图标</span><br><span class="line"></span><br><span class="line">我们也可以使用自定义字体图标。iconfont.cn 上有很多字体图标素材，我们可以选择自己需要的图标打包下载后，会生成一些不同格式的字体文件，在 Flutter 中，我们使用 ttf 格式即可。</span><br><span class="line"></span><br><span class="line">导入字体图标文件，路径为&quot;fonts/iconfont.ttf&quot;：</span><br></pre></td></tr></table></figure></p>
<p>fonts:</p>
<pre><code>- family: appIconFont
  fonts:
    - asset: assets/fonts/iconfont.ttf
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了使用方便，我们定义一个 appIconFont 类，功能和 Icons 类一样：将字体文件中的所有图标都定义成静态变量：</span><br><span class="line"></span><br><span class="line">包装</span><br></pre></td></tr></table></figure>
<p>class Constants {<br>  static const IconFontFamily = “appIconFont”;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用</span><br></pre></td></tr></table></figure></p>
<p>IconButton(<br>    icon: Icon(IconData(<br>      0xe65e,<br>      fontFamily: Constants.IconFontFamily,<br>    ), size: 22.0),<br>    onPressed: () { print(‘点击了搜索按钮’); },<br>),<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 布局</span><br><span class="line">## 简介</span><br><span class="line">布局类的 Widget 都会包含一个或者多个 widget，不同的布局类对子 widget 的排版方式不同。</span><br><span class="line"></span><br><span class="line">###  类型作用特点</span><br><span class="line">| 类型 | 作用特点 |</span><br><span class="line">| :--- | :--- |</span><br><span class="line">| Container | 只有一个子 Widget。默认充满，包含了padding、margin、color、宽高、decoration 等配置。 |</span><br><span class="line">| Padding | 只有一个子 Widget。只用于设置Padding，常用于嵌套child，给child设置padding。 |</span><br><span class="line">| Center | 只有一个子 Widget。只用于居中显示，常用于嵌套child，给child设置居中。 |</span><br><span class="line">| Stack | 可以有多个子 Widget。 子Widget堆叠在一起。 |</span><br><span class="line">| Colum | 可以有多个子 Widget。垂直布局。 |</span><br><span class="line">| Row | 可以有多个子 Widget。水平布局。 |</span><br><span class="line">| Expanded | 只有一个子 Widget。在 Colum 和 Row 中充满。 |</span><br><span class="line">| ListView | 可以有多个子 Widget。自己意会吧。 |</span><br><span class="line">### Row</span><br><span class="line">Row 可以在水平方向排列其 Widget：</span><br></pre></td></tr></table></figure></p>
<p>Row({<br>    Key key,<br>    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,<br>    MainAxisSize mainAxisSize = MainAxisSize.max,<br>    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,<br>    TextDirection textDirection,<br>    VerticalDirection verticalDirection = VerticalDirection.down,<br>    TextBaseline textBaseline,<br>    List<widget> children = const <widget>[],<br>  }) : super(<br>    children: children,<br>    key: key,<br>    direction: Axis.horizontal,<br>    mainAxisAlignment: mainAxisAlignment,<br>    mainAxisSize: mainAxisSize,<br>    crossAxisAlignment: crossAxisAlignment,<br>    textDirection: textDirection,<br>    verticalDirection: verticalDirection,<br>    textBaseline: textBaseline,<br>  );<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- textDirection：是从左往右还是从右往左，默认为系统当前 Locale 环境的文- 本方向（如中文、英语都是从左往右，而阿拉伯语是从右往左）；</span><br><span class="line">- mainAxisSize：表示 Row 在主轴（水平）方向占用的空间；</span><br><span class="line">- mainAxisAlignment：表示子 Widgets 在 Row 所占用的水平空间内对齐方式；</span><br><span class="line">- verticalDirection：表示 Row 纵轴（垂直）的对齐方向；</span><br><span class="line">- crossAxisAlignment：表示子 Widgets 在纵轴方向的对齐方式；</span><br><span class="line">- children ：子 Widgets 数组。</span><br><span class="line"></span><br><span class="line">### Column</span><br><span class="line"></span><br><span class="line">Column 可以在垂直方向排列其子 Widget：</span><br></pre></td></tr></table></figure></widget></widget></p>
<p>Column({<br>    Key key,<br>    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,<br>    MainAxisSize mainAxisSize = MainAxisSize.max,<br>    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,<br>    TextDirection textDirection,<br>    VerticalDirection verticalDirection = VerticalDirection.down,<br>    TextBaseline textBaseline,<br>    List<widget> children = const <widget>[],<br>  }) : super(<br>    children: children,<br>    key: key,<br>    direction: Axis.vertical,<br>    mainAxisAlignment: mainAxisAlignment,<br>    mainAxisSize: mainAxisSize,<br>    crossAxisAlignment: crossAxisAlignment,<br>    textDirection: textDirection,<br>    verticalDirection: verticalDirection,</widget></widget></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">属性和 Row 差不多。</span><br><span class="line"></span><br><span class="line">### mainAxis 主轴</span><br><span class="line">**mainAxisAlignment:**</span><br><span class="line">这个属性在 Row 和 Column 中都有：</span><br><span class="line"></span><br><span class="line">1. start，开始；  </span><br><span class="line">2. end，尾部；  </span><br><span class="line">3. center，中间；  </span><br><span class="line">4. spaceAround，周围；  </span><br><span class="line">5. spaceBetween，从两端开始分配；  </span><br><span class="line">6. spaceEvenly，把剩余空间平均分配在各组件之间。  </span><br><span class="line">### cross 交叉轴  </span><br><span class="line">crossAxisAlignment  </span><br><span class="line">交叉轴的意思就是和 Row 或者 Column 相反的轴。  </span><br><span class="line"></span><br><span class="line">1. start，顶部；</span><br><span class="line">2. end，底部；</span><br><span class="line">3. stretch，拉升；</span><br><span class="line">4. center。</span><br><span class="line">5. SizedBox 固定尺寸的盒子</span><br><span class="line">6. SizedBox 可以用来做一个外部容器，它包含一个子容器，设置宽和高。</span><br><span class="line"></span><br><span class="line">### AspectRatio 宽高比</span><br><span class="line"></span><br><span class="line">AspectRatio 它会根据子部件的最大宽度来设置子部件的宽高。同样它也包含一个子容器。 例如：aspectRatio：16.0/9.0</span><br><span class="line"></span><br><span class="line">### ConstrainedBox 限制</span><br><span class="line">ConstrainedBox 包含一个子部件，它可以用来限制子部件的最大最小宽和高。</span><br><span class="line"></span><br><span class="line"># Widget 状态管理</span><br><span class="line">和 Android 的 Activity，iOS 的 UIViewController 一样，Flutter 中的视图 Widget 也存在生命周期，生命周期的回调函数提现在了 State 上面。理解 Flutter 的生命周期，对我们写出一个合理的控件至关重要。组件 State 的生命周期整理如下图所示：</span><br><span class="line">![image](/img/flutter-1-8.png)</span><br><span class="line">（图片来自网络）</span><br><span class="line"></span><br><span class="line">## State 生命周期</span><br><span class="line">理解 State 的生命周期类似 iOS UIViewController 的声明周期，对于开发非常重要。</span><br><span class="line"></span><br><span class="line">- initState：当 Widget 第一次插入到 Widget 树时会被调用，对于每一个 State 对象，Flutter framework 只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等；</span><br><span class="line">- didChangeDependencies()：当 State 对象的依赖发生变化时会被调用；例如：在之前 build() 中包含了一个 InheritedWidget，然后在之后的 build() 中 InheritedWidget 发生了变化，那么此时 InheritedWidget 的子 Widget 的 didChangeDependencies() 回调都会被调用。典型的场景是当系统语言 Locale 或应用主题改变时，Flutter framework 会通知 Widget 调用此回调；</span><br><span class="line">- build()：此回调读者现在应该已经相当熟悉了，它主要是用于构建 Widget 子树的，会在如下场景被调用:</span><br><span class="line">1. 在调用 initState() 之后；</span><br><span class="line">2. 在调用 didUpdateWidget() 之后；</span><br><span class="line">3. 在调用 setState() 之后；</span><br><span class="line">4. 在调用 didChangeDependencies() 之后；</span><br><span class="line">- reassemble()：此回调是专门为了开发调试而提供的，在热重载（hot reload）时会被调用，此回调在 Release 模式下永远不会被调用；</span><br><span class="line">- didUpdateWidget()：在 widget 重新构建时，Flutter framework 会调用 Widget.canUpdate 来检测 Widget 树中同一位置的新旧节点，然后决定是否需要更新，如果 Widget.canUpdate 返回 true 则会调用此回调。正如之前所述，Widget.canUpdate 会在新旧 widget 的 key 和 runtimeType 同时相等时会返回 true，也就是说在在新旧 widget 的 key和runtimeType 同时相等时 didUpdateWidget() 就会被调用；</span><br><span class="line">- deactivate()：当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework 会将 State对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过 GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用 dispose() 方法；</span><br><span class="line">- dispose()：当 State 对象从树中被永久移除时调用；通常在此回调中释放资源。</span><br><span class="line">### Stream</span><br><span class="line">Stream 是一种数据流的订阅管理。Stream 可以接受任何类型的数据，值、事件、对象、集合、映射、错误、甚至是另一个 Stream，通过 StreamController 中的 sink 作为入口，往 Stream 中插入数据，然后通过你的自定义监听 StreamSubscription 对象，接收数据变化的通知。</span><br><span class="line"></span><br><span class="line">- Stream 有两种类型：单订阅和广播订阅；</span><br><span class="line">- StreamSubscription 可以控制订阅状态，暂停，恢复，取消；</span><br><span class="line">- StreamController 控制管理 Stream；</span><br><span class="line">- StreamSink 添加数据；</span><br><span class="line">- StreamTransformer 可以添加数据的处理；</span><br><span class="line">- StreamBuilder 父类 StreamBuilderBase，StreamBuilderBase 继承自 StatefulWidget，它通过监听 Stream，有数据输出时，调用 builder 方法创建 Widget。</span><br><span class="line">``` </span><br><span class="line">import &apos;dart:async&apos;;</span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">class StreamDemo extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      body: StreamDemoHome(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class StreamDemoHome extends StatefulWidget &#123;</span><br><span class="line">  _StreamDemoHomeState createState() =&gt; _StreamDemoHomeState();</span><br><span class="line">&#125;</span><br><span class="line">class _StreamDemoHomeState extends State&lt;StreamDemoHome&gt; &#123;</span><br><span class="line">  StreamSubscription _streamDemoSubscriptionA;</span><br><span class="line">  StreamSubscription _streamDemoSubscriptionB;</span><br><span class="line">  StreamController&lt;String&gt; _streamDemoController;</span><br><span class="line">  StreamSink _sinkDemo;</span><br><span class="line">  String _data = &apos;...&apos;;</span><br><span class="line">  @override</span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    super.dispose();</span><br><span class="line">    _streamDemoController.close();</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    super.initState();</span><br><span class="line">    //Stream&lt;String&gt; _streamDemo = Stream.fromFuture(fetchData());</span><br><span class="line">    // _streamDemoController = StreamController&lt;String&gt;();</span><br><span class="line">    // _streamDemoSubscription =  _streamDemoController.stream.listen(onData, onError: onError,onDone: onDone);</span><br><span class="line">    //创建可以多个订阅的 broadcast</span><br><span class="line">    _streamDemoController = StreamController.broadcast();</span><br><span class="line">    //第一次订阅</span><br><span class="line">    _streamDemoController.stream</span><br><span class="line">        .listen(onDataA, onError: onErrorA, onDone: onDoneA);</span><br><span class="line">    //第二次订阅</span><br><span class="line">    _streamDemoController.stream</span><br><span class="line">        .listen(onDataB, onError: onErrorB, onDone: onDoneB);</span><br><span class="line">    _streamDemoSubscriptionB = _streamDemoController.stream</span><br><span class="line">                          .where((value) =&gt; (value == &apos;hello1&apos;))</span><br><span class="line">                          .listen((value) =&gt; print(&apos;subscription B $value&apos;));</span><br><span class="line">    _sinkDemo = _streamDemoController.sink;</span><br><span class="line">  &#125;</span><br><span class="line">  Future&lt;String&gt; fetchData() async &#123;</span><br><span class="line">    //延迟3秒钟</span><br><span class="line">    await Future.delayed(Duration(seconds: 2));</span><br><span class="line">    return &apos;hello&apos;;</span><br><span class="line">    //throw &apos;something error &apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  //第一次订阅处理</span><br><span class="line">  void onDataA(String data) &#123;</span><br><span class="line">    print(&apos;A:$data&apos;);</span><br><span class="line">    //这里用来修改_data状态值</span><br><span class="line">    setState(() &#123;</span><br><span class="line">          _data = data;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  void onErrorA(error) &#123;</span><br><span class="line">    print(&apos;A Error: $error&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  void onDoneA() &#123;</span><br><span class="line">    print(&apos;A done&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  //第二次订阅处理</span><br><span class="line">  void onDataB(String data) &#123;</span><br><span class="line">    print(&apos;B:$data&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  void onErrorB(error) &#123;</span><br><span class="line">    print(&apos;B Error: $error&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  void onDoneB() &#123;</span><br><span class="line">    print(&apos;B done&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      child: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            // Text(&apos;$_data&apos;),</span><br><span class="line">            StreamBuilder(</span><br><span class="line">              stream: _streamDemoController.stream,</span><br><span class="line">              //设置初始值</span><br><span class="line">              initialData: &apos;...&apos;,</span><br><span class="line">              builder: (context,snapshot)&#123;</span><br><span class="line">                return Text(&apos;$&#123;snapshot.data&#125;&apos;);</span><br><span class="line">              &#125;</span><br><span class="line">            ),</span><br><span class="line">            Row(</span><br><span class="line">              mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                FlatButton(</span><br><span class="line">                  child: Text(&apos;Add&apos;),</span><br><span class="line">                  onPressed: () async &#123;</span><br><span class="line">                    String data = await fetchData();</span><br><span class="line">                    // _streamDemoController.add(data);</span><br><span class="line">                    //这里使用sink添加数据</span><br><span class="line">                    _sinkDemo.add(data);</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">                FlatButton(</span><br><span class="line">                  child: Text(&apos;Pause&apos;),</span><br><span class="line">                  onPressed: () &#123;</span><br><span class="line">                    _streamDemoSubscriptionA.pause();</span><br><span class="line">                    print(&apos;pause&apos;);</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">                FlatButton(</span><br><span class="line">                  child: Text(&apos;Resume&apos;),</span><br><span class="line">                  onPressed: () &#123;</span><br><span class="line">                    _streamDemoSubscriptionA.resume();</span><br><span class="line">                    print(&apos;resume&apos;);</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">                FlatButton(</span><br><span class="line">                  child: Text(&apos;Cancel&apos;),</span><br><span class="line">                  onPressed: () &#123;</span><br><span class="line">                    _streamDemoSubscriptionA.cancel();</span><br><span class="line">                    print(&apos;cancel&apos;);</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态维护<br>从父容器传入值<br>父容器传递，需要定义好对应的构造函数。缺点是层级关系太多的时候，代码不优雅。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class ChipItem extends StatelessWidget &#123;</span><br><span class="line">  final int count;</span><br><span class="line">  ChipItem(this.count);</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Center(</span><br><span class="line">      child: Chip(</span><br><span class="line">        label: Text(&apos;$count&apos;)</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从父容器传入回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ChipItem extends StatelessWidget &#123;</span><br><span class="line">  final int count;</span><br><span class="line">  final VoidCallback increaeCount;</span><br><span class="line">  ChipItem(this.count,this.increaeCount);</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Center(</span><br><span class="line">      child: ActionChip(</span><br><span class="line">        label: Text(&apos;$count&apos;),</span><br><span class="line">        onPressed: increaeCount,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上两种方式在实际开发中不推荐使用，因为会修改很多组件传值。</p>
<h2 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2><p>InheritedWidget 非常重要的一个功能型 Widget，它提供了从上到下的数据传递方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class CounterProvider extends InheritedWidget &#123;</span><br><span class="line">  final int count;</span><br><span class="line">  final VoidCallback increaseCount;</span><br><span class="line">  final Widget child;</span><br><span class="line">  CounterProvider(&#123;</span><br><span class="line">    this.count,</span><br><span class="line">    this.increaseCount,</span><br><span class="line">    this.child,</span><br><span class="line">  &#125;) : super(child: child);</span><br><span class="line">  static CounterProvider of(BuildContext context) =&gt;</span><br><span class="line">      context.inheritFromWidgetOfExactType(CounterProvider);</span><br><span class="line">  @override</span><br><span class="line">  bool updateShouldNotify(InheritedWidget oldWidget) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class CounterModel extends Model &#123;</span><br><span class="line">  int _count = 0;</span><br><span class="line">  int get count =&gt; _count;</span><br><span class="line">  void increaseCount() &#123;</span><br><span class="line">    _count += 1;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ScopedModel"><a href="#ScopedModel" class="headerlink" title="ScopedModel"></a>ScopedModel</h2><p>Scoped_model 是一个三方库，使用它可以方便的将数据模型从父容器（Widget）传递到它的所有子部件，在数据模型的状态发生变化时，重新渲染当前 Widget 下的所有子 Widget。</p>
<p>使用 Scoped_model ，首先在 pubspec.yaml 文件中添加依赖库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies:</span><br><span class="line">  http: ^0.12.0</span><br><span class="line">  flutter_swiper: ^1.0.6</span><br><span class="line">  flutter:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  flutter_localizations:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  scoped_model: ^1.0.1</span><br></pre></td></tr></table></figure></p>
<p>执行以下命令安装依赖库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flutter packages get</span><br><span class="line">``` </span><br><span class="line">接下来，我们设计一个两个界面。</span><br><span class="line"></span><br><span class="line">在第一个界面中包含三个功能：第一、显示数据（Text）。第二、一个修改数据的按钮（RaisedButton）、第三、一个页面跳转的按钮（FloatingActionButton）。</span><br><span class="line"></span><br><span class="line">在第二个界面中也包含三个功能：第一、返回上一个界面的导航按钮（AppBar），第二、显示数据（Text），第三、一个修改数据的按钮（RaisedButton）。</span><br><span class="line"></span><br><span class="line">我们希望在 First Page 中修改数据，跳转到 Second Page，显示同样的数据，反之在 Second Page 中修改数据，返回上一级界面（First Page）时，也能显示最新的数据状态。</span><br></pre></td></tr></table></figure></p>
<p><strong>第一步：</strong><br>创建 Dart 文件：ScopedmodelDemo.dart，并引入 scoped_model 的包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:scoped_model/scoped_model.dart&apos;;</span><br></pre></td></tr></table></figure></p>
<p><strong>第二步：</strong><br>定义一个继承制 Model 的子类：CounterModel，并定义一个属性，一个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CounterModel extends Model &#123;</span><br><span class="line">  int _count = 0;</span><br><span class="line">  int get count =&gt; _count;</span><br><span class="line">  void increaseCount() &#123;</span><br><span class="line">    _count += 1;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>notifyListeners() 非常关键，当 CounterModel 状态发生变化时，通知所有的 listener。以下是它的源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@protected</span><br><span class="line">  void notifyListeners() &#123;</span><br><span class="line">    // We schedule a microtask to debounce multiple changes that can occur</span><br><span class="line">    // all at once.</span><br><span class="line">    if (_microtaskVersion == _version) &#123;</span><br><span class="line">      _microtaskVersion++;</span><br><span class="line">      scheduleMicrotask(() &#123;</span><br><span class="line">        _version++;</span><br><span class="line">        _microtaskVersion = _version;</span><br><span class="line">        // Convert the Set to a List before executing each listener. This</span><br><span class="line">        // prevents errors that can arise if a listener removes itself during</span><br><span class="line">        // invocation!</span><br><span class="line">        _listeners.toList().forEach((VoidCallback listener) =&gt; listener());</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>第三步：</strong><br>创建第一个界面 Widget，同时初始化上面定义的 CounterModel。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class ScopedmodelDemo extends StatelessWidget &#123;</span><br><span class="line">  ScopedmodelDemo();</span><br><span class="line">  final CounterModel model = CounterModel();</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return ScopedModel&lt;CounterModel&gt;(</span><br><span class="line">      model: model,</span><br><span class="line">      child: new MaterialApp(</span><br><span class="line">        home: ScopedmodelDemoFirstPage(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ScopedmodelDemoFirstPage extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return ScopedModelDescendant&lt;CounterModel&gt;(</span><br><span class="line">      builder: (context, child, model) &#123;</span><br><span class="line">        return Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(&apos;First Page&apos;),</span><br><span class="line">          ),</span><br><span class="line">          body: Center(</span><br><span class="line">            child: Column(</span><br><span class="line">              mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Text(</span><br><span class="line">                  model.count.toString(),</span><br><span class="line">                  style: TextStyle(fontSize: 48.0),</span><br><span class="line">                ),</span><br><span class="line">                RaisedButton(</span><br><span class="line">                  child: Text(&apos;+&apos;),</span><br><span class="line">                  onPressed: () &#123;</span><br><span class="line">                    model.increaseCount();</span><br><span class="line">                  &#125;,</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          floatingActionButton: FloatingActionButton(</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              Navigator.of(context)</span><br><span class="line">                  .push(MaterialPageRoute(builder: (BuildContext context) &#123;</span><br><span class="line">                return ScopedmodelDemoSecondPage(</span><br><span class="line">                  title: &quot;Second Page&quot;,</span><br><span class="line">                );</span><br><span class="line">              &#125;));</span><br><span class="line">            &#125;,</span><br><span class="line">            child: Icon(Icons.forward),</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>ScopedmodelDemo 是我们在程序启动路由的一个入口界面，我们希望由这个入口界面展示第一个 widget 和 第二个 widge；</li>
<li>使用 ScopedModel ，来包装 MaterialApp，且传入一个model对象， 这样所有的子部件都可以访问和操作 model 对象；</li>
<li>ScopedModelDescendant 用来获取 model，它也是继承自 StatelessWidget；</li>
<li><p>显示数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Text(</span><br><span class="line">  model.count.toString(),</span><br><span class="line">  style: TextStyle(fontSize: 48.0),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作数据<br>model.increaseCount();<br>跳转第二个界面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context)</span><br><span class="line">  .push(MaterialPageRoute(builder: (BuildContext context) &#123;</span><br><span class="line">return ScopedmodelDemoSecondPage(</span><br><span class="line">  title: &quot;Second Page&quot;,</span><br><span class="line">);</span><br><span class="line">&#125;));</span><br><span class="line">``` </span><br><span class="line">**第四步：**</span><br><span class="line">实现第二个界面</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>class ScopedmodelDemoSecondPage extends StatelessWidget {<br>  final String title;<br>  ScopedmodelDemoSecondPage({Key key, this.title});<br>  @override<br>  Widget build(BuildContext context) {<br>    return ScopedModelDescendant<countermodel>(<br>        builder: (context, child, model) {<br>      return Scaffold(<br>        appBar: AppBar(<br>          title: Text(‘Second Page’),<br>        ),<br>        body: Center(<br>          child: Column(<br>            mainAxisAlignment: MainAxisAlignment.center,<br>            children: <widget>[<br>              Text(<br>                model.count.toString(),<br>                style: TextStyle(fontSize: 48.0),<br>              ),<br>              RaisedButton(<br>                child: Text(‘+’),<br>                onPressed: () {<br>                  model.increaseCount();<br>                },<br>              ),<br>            ],<br>          ),<br>        ),<br>      );<br>    });<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- 第二个界面和第一个界面类似，同样也是通过 ScopedModelDescendant 获取当前 model，然后显示或者调用其方法。</span><br><span class="line">到此，关于 scoped_model 的 demo 就完成了，通过 scoped_model，我们实现了两个界面对数据的修改且同步，全程都未使用 StatefulWidget。另外在实际开发中 ScopedModelDescendant 的作用范围应该 缩小，避免响应时，重新渲染太多的 Widget，这样有利于提高性能。</span><br><span class="line"></span><br><span class="line">### Redux</span><br><span class="line">A predictable state container for JavaScript apps. 这是 Redux官网上对它的说明解释。</span><br><span class="line"></span><br><span class="line">Redux 是一种状态容器，可以提供可预测的状态管理。Redux 由 Flux 演变而来，但避开了 Flux 复杂性。Redux 可以处理应用中数据的共享状态，你可以在应用的任何位置快速访问这些共享的状态数据。</span><br><span class="line"></span><br><span class="line">Redux 有三个基本的原则：</span><br><span class="line"></span><br><span class="line">- 单一数据源</span><br><span class="line">整个应用的状态被存放在为一的一个 Store 中。</span><br><span class="line"></span><br><span class="line">- State 不可以随意修改</span><br><span class="line">如果想要修改 State，必须出发 action。</span><br><span class="line"></span><br><span class="line">- 使用 Reducer</span><br><span class="line">Reducer 是状态生成器，它有两个参数：state，action。</span><br><span class="line"></span><br><span class="line">我们还是使用两个界面的 demo，使用 Redux 来实现状态共享和状态更新。</span><br><span class="line"></span><br><span class="line">#### 第一步：</span><br><span class="line">添加 Redux 依赖库</span><br></pre></td></tr></table></figure></widget></countermodel></p>
<p>dependencies:<br>  http: ^0.12.0<br>  flutter_swiper: ^1.0.6<br>  flutter:<br>    sdk: flutter<br>  flutter_localizations:<br>    sdk: flutter<br>  scoped_model: ^1.0.1<br>  flutter_redux: ^0.5.2<br>flutterredux 是 Redux 在 flutter 的封装和实现。详细的使用说明参考 <a href="https://pub.dartlang.org/packages/flutterredux" target="_blank" rel="noopener">https://pub.dartlang.org/packages/flutterredux</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 第二步：</span><br><span class="line">创建 State</span><br></pre></td></tr></table></figure></p>
<p>class CounterState {<br>  int _count = 0;<br>  int get count =&gt; _count;<br>  CounterState(this._count);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 第三步：</span><br><span class="line">定义 Action，你可以认为 Action 就是一个对状态操作的动作类型，且唯一。界面组件交互会选择对应的 Action。</span><br></pre></td></tr></table></figure></p>
<p>enum ActionType {<br>  actionTypeA,<br>  actionTypeB<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 第四步：</span><br><span class="line">创建 reducer，reducer 是状态生成器，它会根据 action 类型，创建对应的 CounterState。</span><br></pre></td></tr></table></figure></p>
<p>CounterState reducer(CounterState state,action){<br>  //匹配Action<br>    if(action == ActionType.actionTypeA){<br>      return CounterState(state.count+1);<br>    } else if (action == ActionType.actionTypeB) {<br>      return CounterState(state.count-1);<br>    }<br>    return state;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 第五步：</span><br><span class="line">创建 Store，全局只有一个唯一的 store，所以我们放在入口处。</span><br></pre></td></tr></table></figure></p>
<p>class ReduxDemo extends StatelessWidget {<br>  ReduxDemo();<br>  final store =<br>      Store<counterstate>(reducer, initialState: CounterState.initState());<br>  @override<br>  Widget build(BuildContext context) {<br>    return StoreProvider<counterstate>(<br>      store: store,<br>      child: new MaterialApp(<br>        title: ‘Redux Demo’,<br>        home: ReduxDemoFirstPage(),<br>      ),<br>    );<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reducer， 为处理 action，状态生成器。</span><br><span class="line">CounterState.initState()，状态初始化。</span><br><span class="line">#### 第五步：</span><br><span class="line">显示状态数据</span><br></pre></td></tr></table></figure></counterstate></counterstate></p>
<p>StoreConnector&lt;CounterState, int&gt;(<br>  converter: (store) =&gt; store.state.count,<br>  builder: (context, count) {<br>    return Text(<br>      count.toString(),<br>      style: Theme.of(context).textTheme.display1,<br>    );<br>  },<br>),<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 第六步：</span><br><span class="line">操作状态数据</span><br></pre></td></tr></table></figure></p>
<p>//触发动作<br>StoreConnector&lt;CounterState, VoidCallback&gt;(<br>  converter: (store) {<br>    return () =&gt; store.dispatch(ActionType.actionTypeB);<br>  },<br>  builder: (context, callback) {<br>    return RaisedButton(<br>      child: Text(‘+’),<br>      onPressed: callback,<br>    );<br>  },<br>),<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">完整代码见文章后面的 GitHub 链接。</span><br><span class="line"></span><br><span class="line">## 路由</span><br><span class="line">Flutter 可以通过路由与导航功能，实现多个页面间平滑过渡。</span><br><span class="line"></span><br><span class="line">调转到一个新的全屏页面</span><br><span class="line">要通过导航调转到一个新的页面，可以使用 builder 函数创建 MaterialPageRoute 的实例，该函数可以创建您希望在屏幕上显示的任何内容。</span><br></pre></td></tr></table></figure></p>
<p>Navigator.push(context, MaterialPageRoute<void>(<br>  builder: (BuildContext context) {<br>    return Scaffold(<br>      appBar: AppBar(title: Text(‘My Page’)),<br>      body: Center(<br>        child: FlatButton(<br>          child: Text(‘POP’),<br>          onPressed: () {<br>            Navigator.pop(context);<br>          },<br>        ),<br>      ),<br>    );<br>  },<br>));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过路由构建的页面，是一个全新的页面，而不是原有页面的子控件。这是因为他会在推入堆栈时，在一个新的上下文中构建页面。</span><br><span class="line"></span><br><span class="line">返回上一级页面。</span><br></pre></td></tr></table></figure></void></p>
<p>Navigator.pop(context);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用命名的路由跳转</span><br><span class="line">App 可以定义很多个页面，并且通过一个名字，路径名实现跳转， App 的首页默认命名为&quot;/&quot;。</span><br><span class="line"></span><br><span class="line">我们可以通过配置一个 $Map$创建路由列表。 MaterialApp 通过 Map 实现命名路由的跳转。</span><br></pre></td></tr></table></figure></p>
<p>initialRoute: ‘rxdart’,<br>  //路由<br>  routes: &lt;String, WidgetBuilder&gt;{<br>    ‘/‘: (BuildContext context) =&gt; LaunchPage(title: “Morin”),<br>    ‘one’: (BuildContext context) =&gt; Page(title: ‘page one’),<br>    ‘two’: (BuildContext context) =&gt; Page(title: ‘page two’),<br>    ‘three’: (BuildContext context) =&gt; Page(title: ‘page three’),<br>    ‘state’: (BuildContext context) =&gt; StateManagementDemo(),<br>    ‘scopedmodel’:(BuildContext context) =&gt; ScopedmodelDemo(),<br>    ‘stream’: (BuildContext context) =&gt; StreamDemoHome(),<br>    ‘rxdart’: (BuildContext context) =&gt; RxdartDemo(),<br>    ‘http’: (BuildContext context) =&gt; HttpDemo(),<br>    ‘redux’:(BuildContext context) =&gt; ReduxDemo(),<br>    ‘login’:(BuildContext context) =&gt; LoginFormTestRoute(title:’登录’),<br>  },<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：如果 initialRoute: &apos;/one&apos;，默认他会先展示&apos;/&apos;路由指向的 LaunchPage。</span><br><span class="line"></span><br><span class="line">通过字符串跳转对应的页面</span><br></pre></td></tr></table></figure></p>
<p>//跳转一个页面<br>Navigator.pushNamed(context, ‘/‘);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 路由可以返回值</span><br><span class="line">当跳转一个新的页面，可以在该页面被弹出时，返回一个值。例如，如果我们想让用户按“OK”来确认一个操作，我们可以等待 Navigator.push 的结果。</span><br></pre></td></tr></table></figure></p>
<p>bool value = await Navigator.push(context, MaterialPageRoute<bool>(<br>  builder: (BuildContext context) {<br>    return Center(<br>      child: GestureDetector(<br>        child: Text(‘OK’),<br>        onTap: () { Navigator.pop(context, true); }<br>      ),<br>    );<br>  }<br>));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### 转场动画</span><br><span class="line">你可以通过子类创建自己的 Route，比如 PopupRoute、ModalRoute 或者 PageRoute 来控制跳转页面时的转场动画，颜色透明度等。</span><br><span class="line"></span><br><span class="line">PageRouteBuilder 类可以定义自定义路由。下面是一个示例，当页面出现或消失时，它会附带旋转并淡出的效果。</span><br></pre></td></tr></table></figure></bool></p>
<p>Navigator.push(context, PageRouteBuilder(<br>  opaque: false,<br>  pageBuilder: (BuildContext context, _, <strong>) {<br>    return Center(child: Text(‘My PageRoute’));<br>  },<br>  transitionsBuilder: (_</strong>, Animation<double> animation, ____, Widget child) {<br>    return FadeTransition(<br>      opacity: animation,<br>      child: RotationTransition(<br>        turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),<br>        child: child,<br>      ),<br>    );<br>  }<br>));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">## 动画</span><br><span class="line">因我们对动画研究较少，本章内容来自https://flutterchina.club。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 基本的动画概念和类</span><br><span class="line">- Animation 动画库中的一个核心类；</span><br><span class="line">- AnimationController 管理 Animation；</span><br><span class="line">- CurvedAnimation 将过程抽象为一个非线性曲线；</span><br><span class="line">- Tween 在正在执行动画的对象所使用的数据范围之间生成值。例如，Tween 可能- 会生成从红到蓝之间的色值，或者从 0 到 255；</span><br><span class="line">- 使用 Listeners 和 StatusListeners 监听动画状态改变。</span><br><span class="line">- Flutter 中的动画系统基于 Animation 对象的，Widget 可以在 build 函数中读取 Animation 对象的当前值， 并且可以监听动画的状态改变。</span><br><span class="line"></span><br><span class="line">### Animation</span><br><span class="line">在 Flutter 中，Animation 对象本身和UI渲染没有任何关系。Animation 是一个抽象类，它拥有其当前值和状态（完成或停止）。其中一个比较常用的 Animation 类是 Animation。</span><br><span class="line"></span><br><span class="line">Flutter 中的 Animation 对象是一个在一段时间内依次生成一个区间之间值的类。Animation 对象的输出可以是线性的、曲线的、一个步进函数或者任何其他可以设计的映射。 根据 Animation 对象的控制方式，动画可以反向运行，甚至可以在中间切换方向。</span><br><span class="line"></span><br><span class="line">Animation 还可以生成除 double 之外的其他类型值，如：Animation 或 Animation。</span><br><span class="line"></span><br><span class="line">Animation 对象有状态。可以通过访问其 value 属性获取动画的当前值。</span><br><span class="line"></span><br><span class="line">Animation 对象本身和 UI 渲染没有任何关系。</span><br><span class="line"></span><br><span class="line">### CurvedAnimation</span><br><span class="line">CurvedAnimation 将动画过程定义为一个非线性曲线。</span><br></pre></td></tr></table></figure></double></double></p>
<p>final CurvedAnimation curve =<br>    new CurvedAnimation(parent: controller, curve: Curves.easeIn);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CurvedAnimation 和 AnimationController（在下一节中介绍）都是Animation类型。CurvedAnimation 包装它正在修改的对象 - 您不需要子类 AnimationController 来实现曲线。</span><br><span class="line"></span><br><span class="line">### AnimationController</span><br><span class="line">AnimationController 是一个特殊的 Animation 对象，在屏幕刷新的每一帧，就会生成一个新的值。默认情况下，AnimationController 在给定的时间段内会线性的生成从 0.0 到 1.0 的数字。 例如，下面代码创建一个 Animation 对象，但不会启动它运行：</span><br></pre></td></tr></table></figure></p>
<p>final AnimationController controller = new AnimationController(<br>    duration: const Duration(milliseconds: 2000), vsync: this);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AnimationController 派生自Animation，因此可以在需要Animation 对象的任何地方使用。 但是，AnimationController 具有控制动画的其他方法。例如，.forward() 方法可以启动动画。数字的产生与屏幕刷新有关，因此每秒钟通常会产生 60 个数字，在生成每个数字后，每个 Animation 对象调用添加的 Listener 对象。</span><br><span class="line"></span><br><span class="line">当创建一个 AnimationController 时，需要传递一个 vsync 参数，存在 vsync 时会防止屏幕外动画（译者语：动画的 UI 不在当前屏幕时）消耗不必要的资源。 通过将 SingleTickerProviderStateMixin 添加到类定义中，可以将 stateful 对象作为 vsync 的值。</span><br><span class="line"></span><br><span class="line">### Tween</span><br><span class="line">默认情况下，AnimationController 对象的范围从 0.0 到 1.0。如果您需要不同的范围或不同的数据类型，则可以使用 Tween 来配置动画以生成不同的范围或数据类型的值。例如，以下示例，Tween 生成从 -200.0 到 0.0 的值：</span><br></pre></td></tr></table></figure></p>
<p>final Tween doubleTween = new Tween<double>(begin: -200.0, end: 0.0);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tween 是一个无状态(stateless)对象，需要 begin 和 end 值。Tween 的唯一职责就是定义从输入范围到输出范围的映射。输入范围通常为 0.0 到 1.0，但这不是必须的。</span><br><span class="line"></span><br><span class="line">Tween 继承自 Animatable，而不是继承自 Animation。Animatable 与 Animation 相似，不是必须输出 double 值。例如，ColorTween 指定两种颜色之间的过渡。</span><br></pre></td></tr></table></figure></double></p>
<p>final Tween colorTween =<br>    new ColorTween(begin: Colors.transparent, end: Colors.black54</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tween 对象不存储任何状态。相反，它提供了evaluate(Animation animation)方法将映射函数应用于动画当前值。 Animation 对象的当前值可以通过 value() 方法取到。 evaluate 函数还执行一些其它处理，例如分别确保在动画值为 0.0 和 1.0 时返回开始和结束状态。</span><br><span class="line"></span><br><span class="line">要使用 Tween 对象，请调用其 animate() 方法，传入一个控制器对象。例如，以下代码在 500 毫秒内生成从 0 到 255 的整数值。</span><br></pre></td></tr></table></figure>
<p>final AnimationController controller = new AnimationController(<br>    duration: const Duration(milliseconds: 500), vsync: this);<br>Animation<int> alpha = new IntTween(begin: 0, end: 255).animate(controller);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下示例构建了一个控制器、一条曲线和一个 Tween：</span><br></pre></td></tr></table></figure></int></p>
<p>final AnimationController controller = new AnimationController(<br>    duration: const Duration(milliseconds: 500), vsync: this);<br>final Animation curve =<br>    new CurvedAnimation(parent: controller, curve: Curves.easeOut);<br>Animation<int> alpha = new IntTween(begin: 0, end: 255).animate(curve);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">### 动画通知</span><br><span class="line">一个 Animation 对象可以拥有 Listeners 和 StatusListeners 监听器，可以用 addListener() 和 addStatusListener() 来添加。 只要动画的值发生变化，就会调用监听器。一个Listener最常见的行为是调用 setState() 来触发 UI 重建。动画开始、结束、向前移动或向后移动（如 AnimationStatus 所定义）时会调用 StatusListener。</span><br><span class="line"></span><br><span class="line">### 动画示例</span><br><span class="line">渲染动画</span><br><span class="line">到目前为止，您已经学会了如何随着时间的推移生成一系列数字，但没有任何东西被渲染到屏幕上。 要使用 Animation&lt;&gt; 对象进行渲染，请将 Animation 对象存储为 Widget 的成员，然后使用其 value 值来决定如何绘制。</span><br><span class="line"></span><br><span class="line">考虑下面的应用程序，它绘制 Flutter logo 时没有动画：</span><br></pre></td></tr></table></figure></int></p>
<p>import ‘package:flutter/material.dart’;<br>class LogoApp extends StatefulWidget {<br>  _LogoAppState createState() =&gt; new _LogoAppState();<br>}<br>class _LogoAppState extends State<logoapp> {<br>  Widget build(BuildContext context) {<br>    return new Center(<br>      child: new Container(<br>        margin: new EdgeInsets.symmetric(vertical: 10.0),<br>        height: 300.0,<br>        width: 300.0,<br>        child: new FlutterLogo(),<br>      ),<br>    );<br>  }<br>}<br>void main() {<br>  runApp(new LogoApp());<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改以上代码，通过一个逐渐放大的动画显示 logo。定义 AnimationController 时，必须传入一个 vsync 对象。该 vsync 参数在上面 AnimationController 部分有介绍了 。</span><br></pre></td></tr></table></figure></logoapp></p>
<p>import ‘package:flutter/animation.dart’;<br>import ‘package:flutter/material.dart’;<br>class LogoApp extends StatefulWidget {<br>  _LogoAppState createState() =&gt; new _LogoAppState();<br>}<br>class _LogoAppState extends State<logoapp> with SingleTickerProviderStateMixin {<br>  Animation<double> animation;<br>  AnimationController controller;<br>  initState() {<br>    super.initState();<br>    controller = new AnimationController(<br>        duration: const Duration(milliseconds: 2000), vsync: this);<br>    animation = new Tween(begin: 0.0, end: 300.0).animate(controller)<br>      ..addListener(() {<br>        setState(() {<br>          // the state that has changed here is the animation object’s value<br>        });<br>      });<br>    controller.forward();<br>  }<br>  Widget build(BuildContext context) {<br>    return new Center(<br>      child: new Container(<br>        margin: new EdgeInsets.symmetric(vertical: 10.0),<br>        height: animation.value,<br>        width: animation.value,<br>        child: new FlutterLogo(),<br>      ),<br>    );<br>  }<br>  dispose() {<br>    controller.dispose();<br>    super.dispose();<br>  }<br>}<br>void main() {<br>  runApp(new LogoApp());<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">该 addListener() 函数调用了 setState()，所以每次动画生成一个新的数字时，当前帧被标记为脏（dirty），这会导致 Widget 的 build() 方法再次被调用。 在 build() 中，改变 container 大小，因为它的高度和宽度现在使用的是 animation.value。动画完成时释放控制器（调用 dispose() 方法）以防止内存泄漏。</span><br><span class="line"></span><br><span class="line">用 **AnimatedWidget** 简化</span><br><span class="line">AnimatedWidget 类允许您从 setState() 调用中的动画代码中分离出 Widget 代码。AnimatedWidget 不需要维护一个 State 对象来保存动画。</span><br><span class="line"></span><br><span class="line">在下面的重构示例中，LogoApp 现在继承自 AnimatedWidget 而不是 StatefulWidget。AnimatedWidget 在绘制时使用动画的当前值。LogoApp 仍然管理着 AnimationController 和 Tween。</span><br></pre></td></tr></table></figure></double></logoapp></p>
<p>// Demonstrate a simple animation with AnimatedWidget<br>import ‘package:flutter/animation.dart’;<br>import ‘package:flutter/material.dart’;<br>class AnimatedLogo extends AnimatedWidget {<br>  AnimatedLogo({Key key, Animation<double> animation})<br>      : super(key: key, listenable: animation);<br>  Widget build(BuildContext context) {<br>    final Animation<double> animation = listenable;<br>    return new Center(<br>      child: new Container(<br>        margin: new EdgeInsets.symmetric(vertical: 10.0),<br>        height: animation.value,<br>        width: animation.value,<br>        child: new FlutterLogo(),<br>      ),<br>    );<br>  }<br>}<br>class LogoApp extends StatefulWidget {<br>  _LogoAppState createState() =&gt; new _LogoAppState();<br>}<br>class _LogoAppState extends State<logoapp> with SingleTickerProviderStateMixin {<br>  AnimationController controller;<br>  Animation<double> animation;<br>  initState() {<br>    super.initState();<br>    controller = new AnimationController(<br>        duration: const Duration(milliseconds: 2000), vsync: this);<br>    animation = new Tween(begin: 0.0, end: 300.0).animate(controller);<br>    controller.forward();<br>  }<br>  Widget build(BuildContext context) {<br>    return new AnimatedLogo(animation: animation);<br>  }<br>  dispose() {<br>    controller.dispose();<br>    super.dispose();<br>  }<br>}<br>void main() {<br>  runApp(new LogoApp());<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LogoApp 将 Animation 对象传递给基类并用 animation.value 设置容器的高度和宽度，因此它的工作原理与之前完全相同。</span><br><span class="line"></span><br><span class="line">#### 监视动画的过程</span><br><span class="line">知道动画何时改变状态通常很有用的，如完成、前进或倒退。你可以通过 addStatusListener() 来得到这个通知。 以下代码修改 animate1 示例，以便它监听动态状态更改并打印更新。 下面高亮显示的部分为修改的：</span><br></pre></td></tr></table></figure></double></logoapp></double></double></p>
<p>class _LogoAppState extends State<logoapp> with SingleTickerProviderStateMixin {<br>  AnimationController controller;<br>  Animation<double> animation;<br>  initState() {<br>    super.initState();<br>    controller = new AnimationController(<br>        duration: const Duration(milliseconds: 2000), vsync: this);<br>    animation = new Tween(begin: 0.0, end: 300.0).animate(controller)<br>      ..addStatusListener((state) =&gt; print(“$state”));<br>    controller.forward();<br>  }<br>  //…<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行此代码将输出以下内容：</span><br></pre></td></tr></table></figure></double></logoapp></p>
<p>AnimationStatus.forward<br>AnimationStatus.completed<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接下来，使用 addStatusListener() 在开始或结束时反转动画。这产生了循环效果：</span><br></pre></td></tr></table></figure></p>
<p>class _LogoAppState extends State<logoapp> with SingleTickerProviderStateMixin {<br>  AnimationController controller;<br>  Animation<double> animation;<br>  initState() {<br>    super.initState();<br>    controller = new AnimationController(<br>        duration: const Duration(milliseconds: 2000), vsync: this);<br>    animation = new Tween(begin: 0.0, end: 300.0).animate(controller);<br>    animation.addStatusListener((status) {<br>      if (status == AnimationStatus.completed) {<br>        controller.reverse();<br>      } else if (status == AnimationStatus.dismissed) {<br>        controller.forward();<br>      }<br>    });<br>    controller.forward();<br>  }<br>  //…<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 资源管理</span><br><span class="line">Flutter 应用程序可以包含代码和 assets（有时称为资源）。Assets 是会打包到程序安装包中的，可在运行时访问。常见类型的 Assets 包括静态数据（例如 JSON 文件）、配置文件、图标和图片（JPEG，WebP，GIF，动画 WebP / GIF，PNG，BMP 和 WBMP）等。</span><br><span class="line"></span><br><span class="line">## Assets</span><br><span class="line">Flutter 使用 pubspec.yaml 文件来管理应用程序所需的资源。举一个例子:</span><br></pre></td></tr></table></figure></double></logoapp></p>
<p>flutter:<br>  assets:</p>
<pre><code>- assets/my_icon.png
- assets/background.png
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构建过程支持 Assets 变体的概念：不同版本的 Assets 可能会显示在不同的上下文中。 在 pubspec.yaml 的 Assets 部分中指定 Assets 路径时，构建过程中，会在相邻子目录中查找具有相同名称的任何文件。这些文件随后会与指定的 Assets 一起被包含在 asset bundle 中。</span><br><span class="line"></span><br><span class="line">例如，如果应用程序目录中有以下文件:</span><br><span class="line"></span><br><span class="line">- …/pubspec.yaml</span><br><span class="line">- …/graphics/my_icon.png</span><br><span class="line">- …/graphics/background.png</span><br><span class="line">- …/graphics/dark/background.png</span><br><span class="line">- …etc.</span><br><span class="line">然后 pubspec.yaml 文件中只需包含:</span><br></pre></td></tr></table></figure>
<p>flutter:<br>  assets:</p>
<pre><code>- graphics/background.png
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">iOS、Android 图标和启动图</span><br><span class="line">设置 APP 图标</span><br><span class="line">- Android</span><br><span class="line">在 Flutter 项目的根目录中，导航到 .../android/app/src/main/res 目录，里面包含了各种资源文件夹（如 mipmap-hdpi 已包含占位符图像“ic_launcher.png”）。 只需按照 Android 开发人员指南中的说明， 将其替换为所需的资源，并遵守每种屏幕密度（dpi）的建议图标大小标准。</span><br><span class="line">- iOS</span><br><span class="line">在 Flutter 项目的根目录中，导航到 .../ios/Runner。该目录中 Assets.xcassets/AppIcon.appiconset 已经包含占位符图片。 只需将它们替换为适当大小的图片。保留原始文件名称。</span><br><span class="line">#### 更新启动页</span><br><span class="line">- Android</span><br><span class="line">要将启动屏幕（splash screen）添加到您的 Flutter 应用程序， 请导航至.../android/app/src/main。在 res/drawable/launch_background.xml，通过自定义 drawable 来实现自定义启动界面（你也可以直接换一张图片）。</span><br><span class="line">- iOS</span><br><span class="line">要将图片添加到启动屏幕（splash screen）的中心，请导航至 .../ios/Runner。在 Assets.xcassets/LaunchImage.imageset， 拖入图片，并命名为 LaunchImage.png、LaunchImage@2x.png、LaunchImage@3x.png。 如果你使用不同的文件名，那您还必须更新同一目录中的 Contents.json 文件，图片的具体尺寸可以查看苹果官方的标准。</span><br><span class="line">- 网络</span><br><span class="line">Dart IO 库中提供了 Http 请求的一些类，我们可以直接使用 HttpClient 来发起请求。</span><br><span class="line"></span><br><span class="line">下面的代码，我们实现以下功能：</span><br><span class="line"></span><br><span class="line">- 异步请求网络接口数据；</span><br><span class="line">- 捕获网络请求状态，显示加载提示信息；</span><br><span class="line">- 返回 json 数据，并解析成对应模型 list；</span><br><span class="line">- 在界面上以列表形式显示数据。</span><br></pre></td></tr></table></figure>
<p>import ‘dart:async’;<br>import ‘dart:convert’;<br>import ‘package:http/http.dart’ as http;<br>import ‘package:flutter/material.dart’;<br>class HttpDemo extends StatefulWidget {<br>  @override<br>  State<statefulwidget> createState() =&gt; HttpDemoState();<br>}<br>class HttpDemoState extends State<httpdemo> {<br>  Future _gerData() async {<br>    final response = await http.get(<br>        ‘<a href="http://v.juhe.cn/toutiao/index?key=8521da7cf9c429e44854c3e557a3a874&#39;)" target="_blank" rel="noopener">http://v.juhe.cn/toutiao/index?key=8521da7cf9c429e44854c3e557a3a874&#39;)</a>;<br>    if (response.statusCode == 200) {<br>      final responseBody = json.decode(response.body);<br>      List<toutiao> toutiaos = responseBody[‘result’][‘data’]<br>          .map<toutiao>((item) =&gt; Toutiao.fromJson(item))<br>          .toList();<br>      print(toutiaos);<br>      return toutiaos;<br>    } else {<br>      throw Exception(‘Failed to fetch Toutiaos.’);<br>    }<br>  }<br>  @override<br>  Widget build(BuildContext context) {<br>    return Scaffold(<br>      appBar: AppBar(<br>        title: Text(‘Http Demo’),<br>      ),<br>      body: FutureBuilder(<br>        builder: _buildFuture,<br>        future: _gerData(),<br>      ),<br>    );<br>  }<br>  Widget _buildFuture(BuildContext context, AsyncSnapshot snapshot) {<br>    switch (snapshot.connectionState) {<br>      case ConnectionState.none:<br>        return Text(‘准备连接网络’);<br>      case ConnectionState.active:<br>        return Text(‘ConnectionState.active’);<br>      case ConnectionState.waiting:<br>        return Center(<br>          child: CircularProgressIndicator(),<br>        );<br>      case ConnectionState.done:<br>        if (snapshot.hasError) return Text(‘Error: ${snapshot.error}’);<br>        return _createListView(context, snapshot);<br>      default:<br>        return null;<br>    }<br>  }<br>  Widget _createListView(BuildContext context, AsyncSnapshot snapshot) {<br>    List<toutiao> toutiaos = snapshot.data;<br>    return ListView.builder(<br>      itemBuilder: (context, index) =&gt; _itemBuilder(context, index, toutiaos),<br>      itemCount: toutiaos.length,<br>    );<br>  }<br>  Widget _itemBuilder(BuildContext context, int index, toutiaos) {<br>    if (index.isOdd) {<br>      return Divider();<br>    }<br>    return ListTile(<br>      title: Text(‘${toutiaos[index].title}’),<br>      subtitle: Text(‘${toutiaos[index].authorName}’),<br>      leading: CircleAvatar(<br>        backgroundImage: NetworkImage(‘${toutiaos[index].thumbnailPicS}’),<br>      ),<br>      onTap: () {<br>        print(‘点击:${toutiaos[index].title}’);<br>      },<br>      //trailing: Text(‘${toutiaos[index].category}’),<br>    );<br>  }<br>}<br>/*</toutiao></toutiao></toutiao></httpdemo></statefulwidget></p>
<ul>
<li>头条新闻数据结构<br>*/<br>class Toutiao {<br>final String title;<br>final String thumbnailPicS;<br>final String date;<br>final String category;<br>final String authorName;<br>final String url;<br>Toutiao(this.title, this.thumbnailPicS, this.date, this.category,<br>   this.authorName, this.url);<br>//json to model<br>Toutiao.fromJson(Map json)<br>   : title = json[‘title’],<pre><code>thumbnailPicS = json[&apos;thumbnail_pic_s&apos;],
date = json[&apos;date&apos;],
category = json[&apos;category&apos;],
authorName = json[&apos;author_name&apos;],
url = json[&apos;url&apos;];
</code></pre>//model to json<br>Map toJson() =&gt; {<pre><code>&apos;title&apos;: title,
&apos;thumbnailPicS&apos;: thumbnailPicS,
&apos;date&apos;: date,
&apos;category&apos;: category,
&apos;authorName&apos;: authorName,
&apos;url&apos;: url
</code></pre>   };<br>}<br><code>`</code><br>结尾<br>本文是针对 Flutter 新人入门的一篇文章，后期我们会根据时间推出高级和进阶篇。</li>
</ul>

    </div>
    
        <div class="reward">
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            
                <span class="reward-type">
                    <img class="wechat" src="/img/reward-wepay.jpg"><b>微信打赏</b>
                </span>
            
        </div>
    </div>
    <p class="reward-tip">赞赏是不耍流氓的鼓励</p>
</div>


    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">大力</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
    
        <a href="/2019/01/25/Relearning-2/" class="next-post btn btn-default" title="前端知识架构图-2">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">前端知识架构图-2</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么要用-Flutter-？"><span class="toc-text">为什么要用 Flutter ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flutter-框架结构"><span class="toc-text">Flutter 框架结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flutter-Framework"><span class="toc-text">Flutter Framework</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flutter-Engine"><span class="toc-text">Flutter Engine</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一切皆为-Widget"><span class="toc-text">一切皆为 Widget</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#开发工具"><span class="toc-text">开发工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Dart-介绍"><span class="toc-text">Dart 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#语言特性"><span class="toc-text">语言特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象"><span class="toc-text">面向对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#环境搭建"><span class="toc-text">环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#安装-Flutter"><span class="toc-text">安装 Flutter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#环境诊断"><span class="toc-text">环境诊断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#升级-Flutter"><span class="toc-text">升级 Flutter</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#工程目录"><span class="toc-text">工程目录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建-Flutter-项目"><span class="toc-text">创建 Flutter 项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#目录介绍"><span class="toc-text">目录介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iOS-运行项目"><span class="toc-text">iOS 运行项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-运行项目"><span class="toc-text">Android 运行项目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#基础部件"><span class="toc-text">基础部件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Wideget-简介"><span class="toc-text">Wideget 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Widget-与-Element"><span class="toc-text">Widget 与 Element</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stateless-Widget"><span class="toc-text">Stateless Widget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stateful-Widget"><span class="toc-text">Stateful Widget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础-Widget"><span class="toc-text">基础 Widget</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Text"><span class="toc-text">Text</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按钮"><span class="toc-text">按钮</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FlatButton"><span class="toc-text">FlatButton</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OutlineButton"><span class="toc-text">OutlineButton</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IconButton"><span class="toc-text">IconButton</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义按钮外观"><span class="toc-text">自定义按钮外观</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InheritedWidget"><span class="toc-text">InheritedWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ScopedModel"><span class="toc-text">ScopedModel</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>